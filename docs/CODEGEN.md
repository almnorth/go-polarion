# Code Generation Tool

The `polarion-codegen` CLI tool automatically generates type-safe Go structs from your Polarion configuration, eliminating the need to manually define custom work item types.

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Usage](#usage)
  - [CLI Usage](#cli-usage)
  - [Programmatic Usage](#programmatic-usage)
- [Generated Code](#generated-code)
- [Refresh Mode](#refresh-mode)
- [Examples](#examples)

## Installation

```bash
go install github.com/almnorth/go-polarion/cmd/polarion-codegen@latest
```

## Quick Start

Generate type-safe structs for a specific work item type:

```bash
polarion-codegen \
  --url https://polarion.example.com/rest/v1 \
  --token YOUR_TOKEN \
  --project myproject \
  --type requirement
```

Generate for all work item types in the project:

```bash
polarion-codegen \
  --url https://polarion.example.com/rest/v1 \
  --token YOUR_TOKEN \
  --project myproject
```

## Usage

### CLI Usage

The tool supports the following command-line options:

```bash
polarion-codegen [options]

Options:
  --url string       Polarion REST API base URL (required)
  --token string     Bearer token for authentication (required)
  --project string   Project ID (required)
  --type string      Work item type ID (optional, generates all types if not specified)
  --output string    Output directory (default: "./generated")
  --package string   Package name for generated code (default: "generated")
  --refresh          Refresh existing generated files (preserves custom code)
```

**Examples:**

```bash
# Generate a specific type
polarion-codegen \
  --url https://polarion.example.com/rest/v1 \
  --token YOUR_TOKEN \
  --project myproject \
  --type requirement \
  --output ./models \
  --package models

# Generate all types
polarion-codegen \
  --url https://polarion.example.com/rest/v1 \
  --token YOUR_TOKEN \
  --project myproject

# Refresh existing generated files
polarion-codegen \
  --url https://polarion.example.com/rest/v1 \
  --token YOUR_TOKEN \
  --project myproject \
  --refresh
```

### Programmatic Usage

You can also use the codegen package directly in your Go code:

```go
package main

import (
    "context"
    "log"
    
    polarion "github.com/almnorth/go-polarion"
    "github.com/almnorth/go-polarion/codegen"
)

func main() {
    // Create Polarion client
    client, err := polarion.New(
        "https://polarion.example.com/rest/v1",
        "YOUR_TOKEN",
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // Configure code generation
    config := &codegen.Config{
        OutputDir: "./generated",
        Package:   "generated",
        TypeID:    "", // Empty for all types, or specify like "requirement"
        Refresh:   false,
    }
    
    // Create generator
    gen := codegen.NewGenerator(client, "myproject", config)
    
    // Generate code
    ctx := context.Background()
    if err := gen.Generate(ctx); err != nil {
        log.Fatal(err)
    }
    
    log.Println("Code generation completed successfully")
}
```

## Generated Code

The tool generates a minimal, clean struct with JSON tags for automatic field mapping:

```go
// Code generated by polarion-codegen. DO NOT EDIT manually between generation markers.
// Source: Polarion project "myproject", work item type "requirement"

import polarion "github.com/almnorth/go-polarion"

// Requirement represents a custom requirement work item with type-safe field access.
// Use polarion.LoadCustomFields() and polarion.SaveCustomFields() for automatic field mapping.
type Requirement struct {
    base *polarion.WorkItem

    // Business priority level
    // Enumeration: businessValue
    BusinessValue *string `json:"businessValue,omitempty"`
    // Target release date
    TargetRelease *polarion.DateOnly `json:"targetRelease,omitempty"`
    // Story points for complexity estimation
    ComplexityPoints *float64 `json:"complexityPoints,omitempty"`
    // Whether security review has been completed
    SecurityReviewed *bool `json:"securityReviewed,omitempty"`
}
```

That's it! No boilerplate methods are generated. You use the library's built-in functions:

```go
// Load custom fields from a work item
wi, _ := project.WorkItems.Get(ctx, "REQ-123")
req := &Requirement{base: wi}
polarion.LoadCustomFields(wi, req)

// Access type-safe fields
if req.BusinessValue != nil {
    fmt.Printf("Business Value: %s\n", *req.BusinessValue)
}

// Modify and save back
req.BusinessValue = stringPtr("critical")
polarion.SaveCustomFields(req.base, req)
project.WorkItems.Update(ctx, req.base)
```

## Examples

### Complete Example

See [`examples/codegen/main.go`](../examples/codegen/main.go) for a complete, runnable example.

### Using Generated Code

```go
package main

import (
    "context"
    "fmt"
    "log"
    
    polarion "github.com/almnorth/go-polarion"
    "yourproject/generated"
)

func main() {
    client, _ := polarion.New("https://polarion.example.com/rest/v1", "TOKEN")
    project := client.Project("myproject")
    ctx := context.Background()
    
    // Create a new requirement
    req := &generated.Requirement{
        base: &polarion.WorkItem{
            Type: "workitems",
            Attributes: &polarion.WorkItemAttributes{
                Type:   "requirement",
                Title:  "New Security Feature",
                Status: "draft",
            },
        },
    }
    req.BusinessValue = stringPtr("high")
    req.ComplexityPoints = float64Ptr(8.5)
    
    // Save custom fields and create
    polarion.SaveCustomFields(req.base, req)
    if err := project.WorkItems.Create(ctx, req.base); err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Created requirement: %s\n", req.base.ID)
    
    // Load existing requirement
    wi, _ := project.WorkItems.Get(ctx, "REQ-123")
    req2 := &generated.Requirement{base: wi}
    polarion.LoadCustomFields(wi, req2)
    
    // Type-safe access
    if req2.BusinessValue != nil {
        fmt.Printf("Business Value: %s\n", *req2.BusinessValue)
    }
    if req2.TargetRelease != nil {
        fmt.Printf("Target Release: %s\n", req2.TargetRelease.String())
    }
}

func stringPtr(s string) *string { return &s }
func float64Ptr(f float64) *float64 { return &f }
```

## Field Type Mapping

The tool automatically maps Polarion field types to Go types:

| Polarion Kind | Go Type | Notes |
|---------------|---------|-------|
| `string` | `*string` | Text fields |
| `enumeration` | `*string` | Enum values |
| `integer` | `*int` | Integer numbers |
| `float` | `*float64` | Floating-point numbers |
| `boolean` | `*bool` | Boolean values |
| `time` | `*polarion.TimeOnly` | Time without date |
| `date` | `*polarion.DateOnly` | Date without time |
| `date-time` | `*polarion.DateTime` | Date and time |
| `duration` | `*polarion.Duration` | Time duration |
| `text` | `*polarion.TextContent` | Rich text content |
| `text/html` | `*polarion.TextContent` | HTML content |

All fields are pointers to support nil values (missing/unset fields).

## Best Practices

1. **Version Control**: Commit generated files to track changes over time
2. **Custom Code**: Use the CUSTOM CODE section for validation, business logic, etc.
3. **Refresh Regularly**: Run with `--refresh` when Polarion configuration changes
4. **Separate Package**: Generate into a dedicated package (e.g., `models` or `generated`)
5. **Documentation**: Add comments in the CUSTOM CODE section to document your additions

## Troubleshooting

### Authentication Errors

Ensure your bearer token has sufficient permissions to access:
- Work item type definitions
- Custom field configurations
- Field metadata

### Missing Fields

If fields are missing from generated code:
1. Verify the field exists in Polarion for that work item type
2. Check that the field is properly configured in custom fields
3. Ensure your Polarion version supports the Fields Metadata API (>= 2512)

### Refresh Not Preserving Code

Ensure your custom code is between the markers:
```go
// BEGIN CUSTOM CODE
// Your code here
// END CUSTOM CODE
```

Code outside these markers will be overwritten during refresh.

## See Also

- [Custom Work Items Documentation](CUSTOM-WORKITEMS.md) - Manual approach to custom work items
- [API Reference](API-REFERENCE.md) - Complete API documentation
- [Examples](../examples/) - Working code examples
